when we creates the routes, the order of routes are matter.
in the url if you tyoe localhost:3000/about, you still see the response of the / route only , if we keep the / route as in the first place. because after the / everything becomes wild card.if you check /about/123/xyz. you can still see the same response. even though this route does not exist. so keep in mind that, order of the routes are matter, don't keep the / route in the first place.


#installed postman to test our first API

=> we installed the postman, and created a new workspace for the namaste node.
=>create a new collection, then create a http request. hit enter. successfully tested the get request through postman.

=>we can create a different http methods with the same route name. initially we use app.use(). it can handle all the http methods.
=>but if we want to specifically call a method we need to use app.get(),app.post()etc..


#handling multiple route handlers 
=> we can write multiple handler functions with in a single route.
=> but make sure to understand the how the code is executing, we can only send one respond to the client. we can not send multiple responses from multiple handler request.
=>we must have to send the response to the client, if we don't send the response to the client request, it's keep hanging.

##writing middlwares.....
what is middleware?
middleware is just a normalk handler function , which will handle the routes before sending the response to the clients.
=> we talked about the importance of next().
and order of the arguments in the hanler function is also important. if there are 2 arguments(req,res) if there are 3 (req,res,next) if there are 4 (err,req,res,next)
=> ERROR handling
=> we generally handles the errors in try and catch block. in the most cases , we use next(err) in the catch block, and global error handler function will take care about this error. and we must have to passed the err argument in the end handler function, becuase, express check for the err argument in the fucntion, if it sees in any fucntion handling, it may give improper response.


#creating a database connection.
1) go to mongodb website
2) create a free M0 cluster
3) create a user
4) get the connection string
5)install mongodb compass

#installed mongoose and created a schema and model 
1) with the help of npm i mongoose 
2)once installed the mongoose, create a separate folder called models in src folder.
3)create a file like user.just
4)import mongoose from 'mongoose'
5)if you get stuck follow mongoose documentation to create the schemas.
6) once successfully creating the schema now we need to create a model.
7) with the help of mongoose.model("User", schema name) and export it. 
8) done now u created the schema  and model.

#Now it's time send some data to the databse. it's not a produciton level way. just to understand the basics.
1)we must have to create the schema in the models folder.
2)import the model into the app.js file as of now
3)once imported created an instance of user object and save the new object and send the response to the user.


#it's time to send dynamic data to the signup api.
how do we send the dynamic data with out hardcoding?
:> we can send the dynamic data with the help of end user, it might be postman or browser whatever. but as of now we are using postman.
:> the upper body is the request and bottom one is the response we can see.
:> we need to make  sure ourself what we are doing, we are sending the data or receiving the data or updating the data or deleting the data.
:> depending upon the scenerio we need keep our http method.
:> once it is selected , select the body if we are using post. and keep it raw.
:> there is a difference between javascript object and json object.
:> js objects are key value pair, and in json keys must be string.
;>once we click send we get the response what we send in the endpoint.
:>just remove your hardcoded data and print console.log(req);
:>u can see a lot of things which u don't know.
:> but our main concern is to see our data, which is present in the body.
:> so we do console.log(req.body);\
;> but we see undefined in the console. why?
:> we are sending a json but js objects are different.
:>so we use app.use(express.json()) midleware, which will help us to see the json data in js object.
:> now we can see our data in the console.

#now it's time write more few API's
:>we write get user firstName api and get all the users , and get findById.
:> now we need to update the user details, we have 2 methods in the Model to update the userdetails.
:> one id findOneAndUpdate and findByIdAndUpdate.
 :> we can use both, but if we want to specifically update the user with id , we use findByIdAndUpdate , or if we want to update the user with any one of the field, we can use findOneAndUpdate.
 :> to know more visit mongoose docs.

 #we added the restrictions in the Userschema,
 Why Is Schema Validation Important?
Data Integrity: Ensures incoming requests meet predefined structures and data types.
Security: Prevents injection attacks and other malicious inputs.
Error Handling: Helps return meaningful error messages to clients.
Scalability: Simplifies onboarding new developers by defining clear API contracts.